# Rule-based Data Transformation
# Demonstrates how to use Liminal's rule processor with two pipelines:
# - Compute acceleration magnitude from IMU data, publish as `magnitude_data`, and sink to console
# - Send MQTT messages to toggle an LED on or off based on simulated temperature readings

# Input: Simulated data source
[inputs.random_temp]
type = "simulated"
output = "raw_temp_data"
concurrency = { type = "thread" }
channel = { type = "broadcast", capacity = 256 }
parameters = { field_out = "temperature", distribution = "normal", min_value = -10.0, max_value = 40.0, interval_ms = 5000 }

# Input: MQTT IMU data source
[inputs.mqtt_imu]
type = "mqtt_sub"
output = "raw_imu_data"
concurrency = { type = "thread" }
channel = { type = "broadcast", capacity = 256 }
# Uncomment the following line to read synthetic acceleration data from MQTT (message_gen.sh)
# parameters = { broker_url = "mqtt://localhost:1883", topics = ["test/acceleration"], client_id = "test_mqtt_input", qos = 0, clean_session = true, username = "", password = "" }

# Reading MPU6500 accelerometer data from MQTT
parameters = { broker_url = "mqtt://localhost:1883", topics = ["liminal/sensors/esp32-001/imu"], client_id = "liminal_mqtt_sensor_input", qos = 0, clean_session = true, username = "", password = "" }

#
# Pipelines
#

# [1] Pipelines: MQTT data processing
[pipelines.mqtt_pipeline]
description = "Processes MQTT acceleration data"

[pipelines.mqtt_pipeline.stages.compute_magnitude]
type = "rule"
inputs = ["raw_imu_data"]
output = "accelerator_magnitude_data"

[[pipelines.mqtt_pipeline.stages.compute_magnitude.parameters.rules]]
# Compute acceleration magnitude from IMU data
condition = { field_path = "sensor_type", operation = "equals", value = "imu" }
actions = [
    { type = "keep_only_fields", field_paths = ["device_id"] },
    { type = "compute_field", field_path = "acceleration_magnitude", expression = "sqrt(accelerometer.x^2 + accelerometer.y^2 + accelerometer.z^2)" }
]
else_actions = [
    { type = "drop_message" }
]

# [2] Pipelines: Temperature led pipeline
[pipelines.temperature_led_pipeline]
description = "Processes temperature data and controls LED based on thresholds"

[pipelines.temperature_led_pipeline.stages.temperature_processor]
type = "rule"
inputs = ["raw_temp_data"]
output = "led_commands"

[[pipelines.temperature_led_pipeline.stages.temperature_processor.parameters.rules]]
condition = { field_path = "temperature", operation = ">", value = 15.0 }
actions = [
    { type = "keep_only_fields", field_paths = [] },
    { type = "set_field", field_path = "state", value = true },
]
else_actions = [
    { type = "keep_only_fields", field_paths = [] },
    { type = "set_field", field_path = "state", value = false },
]

# Output: Send LED commands via MQTT
[outputs.led_output]
type = "mqtt_pub"
inputs = ["led_commands"]
parameters = { broker_url = "mqtt://localhost:1883", client_id = "liminal_led_controller_else", clean_session = true, default_topic = "liminal/commands/esp32-001/devices/status_led" }

# Outputs: Console logs
[outputs.log_output]
type = "console"

# Accelerator data output from MQTT/MPU6500
inputs = ["accelerator_magnitude_data"]
